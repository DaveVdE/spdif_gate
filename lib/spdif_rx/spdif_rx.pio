; Copyright (c) 2023, Elehobica
; Released under the BSD-2-Clause
; refer to https://opensource.org/licenses/BSD-2-Clause

; === SPDIF Specification ===
; [Bit] (1 bit = 2 symbols)
; BMC (Bitphase Mark Code)
;          prev   bit0   bit1
; symbol   X 0    1 1    1 0
; symbol   X 1    0 0    0 1
; 
; [Sync] not encoded in BMC (Sync Code = 8 symbols)
; Sync Code B: symbol 1 1 1 0 1 0 0 0 (0xE8)
; Sync Code M: symbol 1 1 1 0 0 0 1 0 (0xE2)
; Sync Code W: symbol 1 1 1 0 0 1 0 0 (0xE4)
;  (inverted code 0x17, 0x1D, 0x1B will not appear unless error)
;
; [SPDIF Sub Frame Format] (64 symbols)
; 16bit Audio Format
; Sync (8) + AUX (8) + '0' (8) + 16bit Audio (32) + VUCP (8)
; 24bit Audio Format
; Sync (8) + 24bit Audio (48) + VUCP (8)
;
; [SPDIF Frame Format] (2 Sub Frames)
; B(L) + W(R) : head block
; M(L) + W(R) : succeeding blocks

; [SPDIF Block Format] (192 Frames = 384 Sub Frames)
; B(L0) + W(R0) + M(L1) + W(R1) + M(L2) + W(R2) + .... + M(L191) + W(R191)

; === spdif_rx PIO program Specification ===
; pio frequency: 96 MHz (sys_clk)
; supported input sampling frequency: 44.1 MHz
; -> symbol clock: 5.6448 MHz (128fs) (17 cycles of sys_clk)
; pio output bit rate: 5.6448 Mbps (No bit loss regardless of the diff between input 44.1KHz and rp2040's 44.1KHz)

; pio outputs (bit order is opposite to SPDIF format)
;
; 16bit Audio Format
; PCUV (4) + 16bit Audio (16) + '0' (4) + AUX (4) + Sync (4)
; 24bit Audio Format
; PCUV (4) + 24bit Audio (24) + Sync (4)
;
;  0b0  : bit0 (symbol_00 or symbol_11)
;  0b1  : bit1 (symbol_10 or symbol_01)
;  0b11 : syncE (symbol_1110) or sync8 (symbol_1000)  (can't distinguish)
;
;   thus Sync Code will consist of as follows
;   0b1111 : Sync Code B (sync E8) (syncE -> sync8)
;   0b1011 : Sync Code M (sync E2) (syncE -> bit0 -> bit1)
;   0b0111 : Sync Code W (sync E4) (syncE -> bit1 -> bit0)

; ==============================================================================================
.program spdif_rx
; it's desirable symbol cycle should meet with sampling frequency of input source
;  at least between 2+1 cycles, then it should keep good latching position of the symbol.
;  (because 'wait' intruction can cancel the delay)
.define cy 17     ; symbol cycle
.define lp cy/2+1 ; symbol latch point (0 ~ cy-1)

; assuming y, osr registers are configured as below
;   y  : 0x00000000
;   osr: 0x00000003

public entry_point:
    wait 0 pin 0

.wrap_target
;                          ; comment                       :  start sym pos   end sym pos
;                                                             (*) symbol latch with delay
wait_1:
    wait 1 pin 0 [cy-1+lp] ; wait for 0 -> 1               :  0                1 + lp/cy
symbol_1x:
    jmp pin symbol_11x     ; If symbol 11 -> go symbol_11x :  1 + lp/cy (*)    1 + (lp+1)/cy
    in osr, 1              ; else emit 1 (symbol 10)       :  1 + (lp+1)/cy    1 + (lp+2)/cy
    jmp wait_1             ; go wait_1                     :  1 + (lp+2)/cy    1 + (lp+3)/cy
symbol_11x:
    nop [cy-2]             ;                               :  1 + (lp+1)/cy    2 + lp/cy
    jmp pin sync1110       ; If symbol 111 -> go sync1110  :  2 + lp/cy (*)    2 + (lp+1)/cy (maximum delayed latch point)
    in y, 1                ; else emit 0 (symbol 110)      :  2 + (lp+1)/cy    2 + (lp+2)/cy
    jmp symbol_0x [cy-3]   ; go symbol_0x                  :  2 + (lp+2)/cy    3 + lp/cy (= 1 + lp/cy)

wait_0:
    wait 0 pin 0 [cy-1+lp] ; wait for 1 -> 0               :  0                1 + lp/cy
symbol_0x:
    jmp pin symbol_01      ; If symbol 01 -> go symbol_01  :  1 + lp/cy (*)    1 + (lp+1)/cy
    in y, 1                ; else emit 0 (symbol 00)       :  1 + (lp+1)/cy    1 + (lp+2)/cy
.wrap
symbol_01:
    in osr, 1              ; emit 1                        :  1 + (lp+1)/cy    1 + (lp+2)/cy
    jmp wait_0             ; go wait_0                     :  1 + (lp+2)/cy    1 + (lp+3)/cy

sync1110:
    push block             ; this is 32bit start
    in osr, 2              ; emit sync (sync 1110)         :  2 + (lp+1)/cy    2 + (lp+2)/cy
    wait 0 pin 0 [cy-1+lp] ; wait for 1 -> 0               :  0                1 + lp/cy
    jmp pin sync1xxx [cy-2]; If sync 1xxx -> go sync1xxx   :  1 + lp/cy (*)    2 + (lp-1)/cy
    jmp symbol_0x          ; else go symbol_0x (sync 0xxx) :  2 + (lp-1)/cy    2 + lp/cy (= 1 + lp/cy)

sync1xxx:                  ; sync1xxx must be sync1000 (no check)
    in osr, 2              ; emit sync (sync 1000)         :  2 + (lp-1)/cy    2 + lp/cy
    jmp entry_point        ;                               :  2 + lp/cy        2 + (lp+1)/cy

; ==============================================================================================
% c-sdk {

static inline void spdif_rx_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);
    pio_gpio_init(pio, pin);
    gpio_pull_down(pin);

    pio_sm_config sm_config = spdif_rx_program_get_default_config(offset);

    sm_config_set_jmp_pin(&sm_config, pin);
    sm_config_set_in_pins(&sm_config, pin); // PINCTRL_IN_BASE for wait
    sm_config_set_in_shift(&sm_config, true, false, 32); // shift_right, no autopush, 32bit

    pio_sm_init(pio, sm, offset, &sm_config);
    pio_sm_set_pins(pio, sm, 0); // clear pins

    // set y, OSR (use as config value)
    pio_sm_set_enabled(pio, sm, false);
    pio_sm_put_blocking(pio, sm, 0x0); // y = 0x0
    pio_sm_exec(pio, sm, pio_encode_pull(false, false));
    pio_sm_exec(pio, sm, pio_encode_out(pio_y, 32));
    pio_sm_put_blocking(pio, sm, 0x3); // osr = 0x3
    pio_sm_exec(pio, sm, pio_encode_pull(false, false)); // only pull to store to osr
    pio_sm_set_enabled(pio, sm, true);

    // fifo join needs to be done after pull/out
    sm_config_set_fifo_join(&sm_config, PIO_FIFO_JOIN_RX);

    pio_sm_exec(pio, sm, pio_encode_jmp(offset + spdif_rx_offset_entry_point));
}

static inline uint32_t spdif_rx_program_get32(PIO pio, uint sm) {
    // 32-bit read from the FIFO, as data is right-justified
    io_rw_32 *rxfifo_shift = (io_rw_32*)&pio->rxf[sm];
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {
        tight_loop_contents();
    }
    return (uint32_t)*rxfifo_shift;
}

%}